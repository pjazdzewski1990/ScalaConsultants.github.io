---
comments: true
date: 2015-02-11 16:10:00
layout: post
slug: event-sourced-dice-game-part1
title: Event-sourced game implementation example - Part 1/3&#58; Getting started
summary: Simple (yet complete) example of game implementation using CQRS and event sourcing backed by Akka persistence and RabbitMQ. Part 1/3
author: Łukasz Gąsior
tags:
- Event Sourcing
- CQRS
- Akka persistence
- RabbitMQ
- Reactive rabbit
- DDD
---

Hi, in this post series we'll create really simple (yet complete) event-sourced game. 
It won't be anything spectacular thus it's rules are as simple as:

- game creator specifies players taking part
- each player, one after another, has an opportunity to roll the dice
- each player's opportunity to roll is time limited, if player won't roll within the limit, his opportunity is gone
- winners are all players who share highest rolled number

With these simple rules it's barely playable but who cares, at least it's event-sourced!

Full source code is available on [GitHub](https://github.com/LukasGasior1/event-sourced-dice-game).

Let's go...

## 1. Architecture overview
![Architecture](https://raw.githubusercontent.com/LukasGasior1/event-sourced-dice-game/master/doc/diagram.png)

We'll split our application into three separate modules: game, webappp and statistics.

Game is our core module, it's where all business logic lives. It has REST API to handle commands and it publishes events
to RabbitMQ. 

Webapp is an example user interface client consuming our game module. It'll be created using Play Framework, AngularJS and WebSocket.

Additionaly, we'll create statistics module that'll collect data from game's events
and expose simple REST API to get calculated dice rolls statistics.

In this part we'll take a look at game module followed by webapp and statistics in 2nd and 3rd part of this series.

## 1. Domain - game's heart
We'll begin with implementing main portion of game's logic - our domain.
There are few ingredients here:

- game - contains game rules logic, an aggregate root
- commands - game is capable of handling them ("Roll the dice" is an example of command)
- violations - if command being handled breaks game's rules (for example if player tries to roll while it's not his turn) we
indicate a violation
- events - they are generated by game when something happens (for example: "Dice has been rolled" or "Game has finished")

### Game
Our game is an event-driven aggregate root. It's immutable and most of its public methods return new copy of itself with some changes.
Applied changes are reflected in generated events added to returned game.

Here's how our game's interface looks loke:

{% highlight scala %}
sealed trait Game {
  def handleCommand(command: GameCommand): GameOrViolation
}

case class UninitializedGame(...) extends Game {
  def start(players: Seq[PlayerId]): GameOrViolation
}

case class RunningGame(...) extends Game {
  def roll(player: PlayerId): GameOrViolation
  def tickCountdown(): Game
}

case class FinishedGame(...) extends Game {}
{% endhighlight %}

As you can see, game can be in one of 3 states:

- uninitialized - right after creation
- running - once started
- finished - after all players roll (or timeout)

### Commands
There are just two commands that our game needs to handle:

{% highlight scala %}
sealed trait GameCommand
case class StartGame(players: Seq[PlayerId]) extends GameCommand
case class RollDice(player: PlayerId) extends GameCommand
{% endhighlight %}

I decided to make `Game` trait responsible for handling these commands, thats what `handleCommand` method does.
It simply dispatches command to corresponding method calls (`start()` or `roll()`).
If command cannot be applied in current state (for example `RollDice` in `UninitializedGame`) it returns suitable violation.
Some may prefer to have `handleCommand` implemented in each subclass instead of `Game` trait. Either ways is fine.

Here's the `handleCommand` method:

{% highlight scala %}
def handleCommand(command: GameCommand): GameOrViolation = command match {
  case StartGame(players) => this match {
    case ug: UninitializedGame => ug.start(players)
    case _ => GameAlreadyStartedViolation
  }
  case RollDice(player) => this match {
    case rg: RunningGame => rg.roll(player)
    case _ => GameNotRunningViolation
  }
}
{% endhighlight %}

Apart from commands we'll have a method to update current turn countdown (`tickCountdown()`).
It'll take care of updating remaining time for player's turn as well as turn timeout.
We'll execute this method periodically as the time passes.

### Violations
You might have already noticed that most of game's public methods return
`GameOrViolation`. It's convenient type alias for `Either[Game, Violation]`.

We'll use following violations:

{% highlight scala %}
sealed trait GameRulesViolation
case object NotEnoughPlayersViolation extends GameRulesViolation
case object NotCurrentPlayerViolation extends GameRulesViolation
case object GameAlreadyStartedViolation extends GameRulesViolation
case object GameNotRunningViolation extends GameRulesViolation
{% endhighlight %}

Here's quick explanation:

- `NotEnoughPlayersViolation` - possibly returned from `start` method if there are not enough players to start a game (in our case, at least 2 needed)
- `NotCurrentPlayerViolation` - returned from `roll` if it's not turn of player who tries to roll
- `GameAlreadyStartedViolation` - created when you try to pass a `Start` command to game that's already started
- `GameNotRunningViolation` - analogous to previous one, in this case it applies to `Roll` command and uninitialized game

### Events
If a command result is a valid game (not a violation), all events generated during this command processing will be added to returned game's `uncommittedEvents` field.
They can later be published, persisted or used in any other way.

Some of events that we'll use are:

{% highlight scala %}
case class GameStarted(..)
case class TurnCountdownUpdated(..)
case class DiceRolled(..)
case class GameFinished(..)
{% endhighlight %}

I hope they are self explanatory.

Appropriate events are generated by game's methods.
Here's simplified version of `roll` method, that generates the event:

{% highlight scala %}
 def roll(player: PlayerId): GameOrViolation = {
    if (turn.currentPlayer == player) {
      val rolledNumber = Random.nextInt(6) + 1
      applyEvent(DiceRolled(id, rolledNumber))
    } else {
      NotCurrentPlayerViolation
    }
  }
{% endhighlight %}

We can see that if everything is fine (it's the `currentPlayer` that rolls) we generate one event: `DiceRolled`.
From `roll` method we return the result of applying this event to current game's state.

What does the `applyEvent` method do then?
Here's example for `DiceRolled` event:

{% highlight scala %}
override def applyEvent = {
  case ev @ DiceRolled(_, rolledNumber) =>
    copy(rolledNumbers = rolledNumbers + (turn.currentPlayer -> rolledNumber),
      uncommittedEvents = uncommittedEvents :+ ev)
}
{% endhighlight %}

New copy of game is created and state updated (here, we add rolled number to `rolledNumbers` map).
Also we add newly applied event to `uncommittedEvents` so that `roll` caller knows what
events were generated.

All state changes happen as a result of events in `applyEvent` method. If we want to change game state
we need to generate an event and apply it.

`applyEvent` is overriden in each of game subclasses and each of them handles different set of events.
For example `DiceRolled` event would be invalid in uninitialized state, thus it's not handled there.

Great feature of this is that having a list of past events we can easily restore current
game state, just by applying them ony by one.

{% highlight scala %}
def applyEvents(events: E*): T =
    events.foldLeft(this)(_ applyEvent _)
{% endhighlight %}

This method is defined in `AggregateRoot` trait that game extends.

Let's get back to `tickCountdown()` for a moment. 
Althought it's not a command it will also generate some events that we can later use:

{% highlight scala %}
def tickCountdown(): Game = {
    val countdownUpdated = TurnCountdownUpdated(id, turn.secondsLeft - 1)
    if (turn.secondsLeft <= 1) {
      val timedOut = TurnTimedOut(id)
      nextPlayerOpt match {
        case Some(nextPlayer) =>
          applyEvents(countdownUpdated, timedOut, TurnChanged(id, Turn(nextPlayer, turnTimeoutSeconds)))
        case None =>
          applyEvents(countdownUpdated, timedOut, GameFinished(id, bestPlayers))
      }
    } else applyEvent(countdownUpdated)
  }
{% endhighlight %}

## 2. Infrastructure - time for Akka persistence
Now that we have our game, we can build some infrastructure around it.
We'll use Akka persistence to run games and make them persistent.

{% highlight scala %}
class GameActor(id: GameId) extends PersistentActor {
  override val persistenceId = id.value

  var game: Game = Game.create(id)
}
{% endhighlight %}

This actor will be responsible for managing game's state (`game` variable), passing commands and updating the time.

`GameActor` will handle commands and pass them to game.

{% highlight scala %}
override def receive = {
  case command: GameCommand => handleResult(game.handleCommand(command))
  ...
}

def handleResult(result: GameOrViolation) = result match {
  case Right(updatedGame) =>
    sender() ! CommandAccepted
    handleChanges(updatedGame)
  case Left(violation) =>
    sender() ! CommandRejected(violation)
  }

def handleChanges(updatedGame: Game) =
  updatedGame.uncommittedEvents.foreach {
    persist(_) { ev =>
      game = game.applyEvent(ev).markCommitted
      publishEvent(ev)
      ...
    }
  }

def publishEvent(event: GameEvent) = {
  system.eventStream.publish(event)
} 
{% endhighlight %}

What's going on here?

1. `GameCommand` is received
2. It's passed to game's `handleCommand` method
3. We inform caller about command's success or failure (`CommandAccepted` and `CommandRejected`)
A note here: using CQRS it's not always possible to immediately tell if something goes wrong
in our case it's easy, so - why not? In less friendly system we could just return acknowledge
to indicate that command processing started but haven't yet completed.
4. If the command succeeded we persist all new events applied (remember `uncommittedEvents`?)
5. After each event is persisted (second argument list in `persist` is a callback) 
we apply it to current game state (the one from before command). Also we mark new state as commited, that is, 
remove all events from `uncommittedEvents`. We don't want them anymore.
6. We publish event (it just pushes it to Akka's built-in `eventStream`)
7. We do other actions based on applied event - ommitted here for brevity, what we do
here is we schedule turn countdown, stop the actor if the game has finished, etc.

`GameActor` will also take care of updating game's time (remember `tickCountdown` method?). 

We'll use built-in scheduler for that. It will call `game.tickCountdown()` every second. 
Once it does it will handle the changes the same way it does in case of a command.

Here's related code:

{% highlight scala %}
  var tickCancellable: Option[Cancellable] = None

override def receiveCommand = {
  ...
  case TickCountdown => game match {
    case rg: RunningGame => handleChanges(rg.tickCountdown())
    case _ =>
      log.warning("Game is not running, cannot update countdown")
      cancelCountdownTick()
  }
}

def scheduleCountdownTick() = {
  val cancellable =
    system.scheduler.schedule(1.second, 1.seconds, self, TickCountdown)
  tickCancellable = Some(cancellable)
}

def cancelCountdownTick() = {
  tickCancellable.foreach(_.cancel())
  tickCancellable = None
}
{% endhighlight %}

## 3. REST API
To create new games and pass commands to existing ones, we'll expose REST API. We'll use spray-can as a server with following routes:

- POST /game - create new game
- POST /game/:id/start - start previously created game
- POST /game/:id/roll/:player - roll request from given player

I realize last two are not very restful, but for our simple example let's just stick with them.

We'll use actor-per-request pattern and create one actor to handle single request.

For create game it looks like this:

{% highlight scala %}
val gameRoute =
  (pathPrefix("game") & post) {
    pathEndOrSingleSlash(handleCreate) // ~ other routes not shown here
  }

def handleCreate: Route = { ctx =>
  actorRefFactory.actorOf(CreateGameRequestActor.props(ctx, gameManager))
}
{% endhighlight %}

And corresponding per-request actor:

{% highlight scala %}
class CreateGameRequestActor(...) extends Actor {

  gameManager ! GameManager.CreateGame

  context.setReceiveTimeout(timeout)

  override def receive = {
    case GameManager.GameCreated(id) =>
      ctx.complete(StatusCodes.Created, CreateGameResponseData(id.value))
      context stop self
    case ReceiveTimeout =>
      ctx.complete(StatusCodes.RequestTimeout)
      context stop self
  }

}
{% endhighlight %}

As you can see all commands go through `GameManager`. It's responsible for creating new `GameActor`s and
passing commands to existing ones.

{% highlight scala %}
class GameManager extends Actor {

  override def receive = {
    case CreateGame =>
      val id = GameId.createRandom
      context.actorOf(GameActor.props(id), id.value)
      sender() ! GameCreated(id)
    case SendCommand(gameId, command) =>
      context.child(gameId.value) match {
        case Some(game) => game forward command
        case None => sender() ! GameDoesNotExist
      }
  }

}
{% endhighlight %}

`SendCommand` is send by second per-request actor we have: `GameCommandRequestActor` used by `start` and `roll` routes.

Once command is processed, per-request actor is stopped.

We already know how can we do some actions with games, but how do we know what's actually happening to them?
Let's get back to our events.

## 4. Feeding the Rabbit
For now events from our games just go to `eventStream` and nothing more happens to them.
It's not very useful. We'd rather want them to be published somewhere where they can be consumed by external clients. 
There are many possibilities: from exposing REST API to fetch recent events (polling) through custom socket-based 
pub/sub implementations on message queues systems finishing. We'll head towards the latter and use RabbitMQ
to publish our events.

I'll use [Reactive rabbit](https://github.com/ScalaConsultants/reactive-rabbit) library to easily bind a stream (of game events) to rabbit exchange.

Our events will go to headers exchange and will have `gameId` and `type` headers (which we can route on in our queues).

Here's how we create an exchange and bind it to publisher:

{% highlight scala %}
val connection = Connection()
val exchange = Exchange(exchangeName, Headers, durable = false)

connection.exchangeDeclare(exchange) onComplete {
  case Success(_) =>
    Source[GameEvent](EventPublisherActor.props)
      .map(toMessage)
      .to(Sink(connection.publish(exchange = exchangeName, "")))
      .run()(ActorFlowMaterializer())
  case Failure(ex) =>
    log.error("Cannot create exchange", ex)
    sys.exit(1)
}

def toMessage(event: GameEvent) = {
  val serialized = compact(render(Extraction.decompose(event)))
  Message(
    body = ByteString(serialized),
    contentType = Some(MediaType.JSON_UTF_8),
    contentEncoding = Some("UTF-8"),
    headers = Map(
      "gameId" -> event.id.value,
      "type" -> event.getClass.getSimpleName))
}
{% endhighlight %}

our publisher is an actor that catches game events from Akka's event stream and publishes them (`onNext`) in accordance to requested demand.

{% highlight scala %}
class EventPublisherActor extends ActorPublisher[GameEvent] {

  var eventCache: List[GameEvent] = Nil

  context.system.eventStream.subscribe(self, classOf[GameEvent])

  override def receive = {
    case Request(n) =>
      while (isActive && totalDemand > 0 && eventCache.nonEmpty) {
        val (head :: tail) = eventCache
        onNext(head)
        eventCache = tail
    }
    case event: GameEvent =>
      if (isActive && totalDemand > 0)
        onNext(event)
      else
        eventCache :+= event
    }

}
{% endhighlight %}

Once it pushes an event, Reactive rabbit takes care of moving it to RabbitMQ.

## 5. Running
Now that we have all building blocks ready it's time for the best part! 

Let's see our game in action.

First, let's run RabbitMQ. I use docker for quick start:

{% highlight bash %}
▶ docker run -d -p 5672:5672 -p 15672:15672 dockerfile/rabbitmq
{% endhighlight %}

Before we start creating games, we'll bind a queue to game_events exchange so that
we can see passing events:

1. Enter rabbit console. If you used docker above it's: http://localhost:15672/
2. Go to Queues and in "Add a new queue" section enter queue name , for example "all_games_events".
3. Click on newly created queue name and in "Bindings" section in "From exchange" field type "game_events"
(leave remaining fields empty). This will bind our queue to all events from all games.

Leter, when there'll be messages going to this queue, you can read them in "Get messages" section of queue view.
Just type how many you want in "Messages" field and hit "Get Messages(s)".

We are now ready to run game application:

{% highlight bash %}
▶ sbt "project game" run
{% endhighlight %}

Let's try creating new game using REST API we have:

{% highlight bash %}
▶ curl -X POST http://127.0.0.1:8081/game      

{"id":"6aa60d73-e9b1-4a3d-a7cc-0a9fd586974d"} 
{% endhighlight %}

The game has been created and we get it's id in response. Great! Let's start it:

{% highlight bash %}
▶ curl -H "Content-Type: application/json" --data '{"players": ["Player1", "Player2"]}' http://127.0.0.1:8081/game/6aa60d73-e9b1-4a3d-a7cc-0a9fd586974d/start

The request has been accepted for processing, but the processing has not been completed
{% endhighlight %}

We just started the game with two players: "Player1" and "Player2". 
The game should be running and generating events now.
Let's check that...

Go back to rabbit console and get some messages in queue overview. Here's what I got:

{% highlight bash %}
// headers:
gameId: 6aa60d73-e9b1-4a3d-a7cc-0a9fd586974d
type: GameStarted

// payload:
{"id":"6aa60d73-e9b1-4a3d-a7cc-0a9fd586974d","players":[{"value":"Player1"},{"value":"Player2"}],"initialTurn":{"currentPlayer":"Player1","secondsLeft":15}}
{% endhighlight %}

{% highlight bash %}
// headers
gameId: 6aa60d73-e9b1-4a3d-a7cc-0a9fd586974d
type: TurnCountdownUpdated

// payload:
{"id":"6aa60d73-e9b1-4a3d-a7cc-0a9fd586974d","secondsLeft":14}
{% endhighlight %}

We can clearly see that the game indeed started and is running. Viola!
Player's turn countdown is being updated every second, and if you wait long enough without any action
you'll surely see TurnTimedOut event in few seconds.

Let's try rolling the dice:

{% highlight bash %}
▶ curl -X POST http://127.0.0.1:8081/game/6aa60d73-e9b1-4a3d-a7cc-0a9fd586974d/roll/Player1

The request has been accepted for processing, but the processing has not been completed.
{% endhighlight %}

Good! We've just rolled the dice. `DiceRolled` event should be generated.

Let's check our validation, what will happen if we try to roll as a player who is not supposed to roll at the moment?

{% highlight bash %}
▶ curl -X POST http://127.0.0.1:8081/game/6aa60d73-e9b1-4a3d-a7cc-0a9fd586974d/roll/Player3

{"message":"Not this player's turn"}
{% endhighlight %}

That's it. Everything works fine.

For those impatient, you can also run webapp and navigate to 9000 to play the game with web interface.

## Summary
I realize this post didn't cover all aspects in detail, I tried to focus on most important ones and I hope it puts some light on
most of them. My goal was to give some basic idea of how CQRS/ES based application could look like.

As a reminder full source code is available on [Github](https://github.com/LukasGasior1/event-sourced-dice-game).

In next part, we'll create simple web application to improve our gaming experiance!
We'll see how to combine REST API calls with event listening to create decent user experiance.

Stay tuned!

Other parts:

- Event-sourced game implementation example - Part 2/3: It's time to play - building web application (IN PROGRESS)
- Event-sourced game implementation example - Part 3/3: Grabbing some data - statistics service (PENDING)
